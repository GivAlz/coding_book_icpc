\chapter{Bugs and Debugging}\label{chapter:debug}

It would be ideal if a program worked exactly as intended the first time it was written, but that is often not the case. It takes only a moment to introduce a bug, but it can often take more than two hours to remove it. Furthermore, when using C or C++, the detection mechanisms and error messages for code that is not guaranteed to work are often unhelpful, which can make it take a long time to find the cause.
Familiarizing yourself with the useful tools available in the development environment may reduce the time spent investigating the cause.
Especially in programming contests, where both time and computer usage are limited, it is desirable for teams to determine efficient methods.

\section{Bug Prevention and Programming Practices}
Paradoxically, to reduce debugging time, it is effective to spend time preventing bugs from being introduced. One way to do this is to adopt good programming styles.
There are various books on this topic, so it is good to find one that suits you. Here are some examples.

\paragraph{Variable Usage} Using variables appropriately makes programs easier to read.

Bad Example: (Calculating the area of a circle where (x1, y1) and (x2, y2) are the endpoints of the diameter)
\begin{cbox}
double area = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))/2
 * sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))/2 * 3.1415;\end{cbox}
Improved Example:
\begin{cbox}
double radius = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))/2;
double area = radius*radius*3.1415;\end{cbox}
Why it's better:
\begin{itemize}
\setlength{\itemsep}{0pt}
\item Easier for humans to read (reduces the places to check if x1 is mistaken for x2)
\item No typing/copy-paste errors
\item Easier to grasp intermediate results (in this case, the radius). (Easy to display with a debugger or printf)
\end{itemize}

\paragraph{Function Usage} Similarly, it leads to more readable programs.
  \begin{cbox}
double square(double x) { return x*x; }
double norm(double x1, double y1, double x2, double y2) {
  return square(x2-x1)+ square(y2-y1);
}
double circle_area(double r) { return r*r*3.1415; }\end{cbox}
\paragraph{Constant Usage} Giving names to constants also improves readability.
  \begin{cbox}
const double pi = 3.1415;
const double pi = atan2(0.0,-1.0);    
\end{cbox}
\paragraph{Keep Variable Scope as Short as Possible}
The shorter the scope of a variable, the better. Relatedly, avoid reusing variables, and it is good to use one variable for only one purpose.
\begin{cbox}[emph={j}]
int i, j, k;
// Suppose there is a function that uses j or k around here
...
int main() {
  for (i=0; j<5; ++i) // Oh no!
    cout << "Hello, world" << endl;
  ...
}
\end{cbox}
Declaring the necessary variables for each function greatly improves the situation.
\begin{cbox}
int main() {
  int i;
  for (i=0; j<5; ++i) // Compilation error
    cout << "Hello, world" << endl;
}
\end{cbox}
However, in modern languages such as C++ and Java, you can declare variables used in loops within the for statement, so this is recommended.
\begin{cbox}
int main() {
  for (int i=0; i<5; ++i) 
    cout << "Hello, world" << endl;
}
\end{cbox}
\paragraph{Avoid Common Pitfalls} There are some things that are good to learn in advance.
    C Language FAQ \url{http://www.kouno.jp/home/c_faq/} Especially 16 Strange Problems
\paragraph{Understand Compiler Messages} Compilers sometimes give helpful advice. Do not ignore them.
  \begin{itemize}
  \item ``if-parenth.cc:8:14: warning: suggest parentheses around assignment used as truth value''
\begin{cbox}
  if (a = 1) return 1;
  if (a =! 1) cout << "ok";
\end{cbox}
\item ``no return statement in function returning non-void [-Wreturn-type]''
\begin{cbox}
int add(int a, int b) {
  a+b; // Correctly \cemph{return} a+b;
}
\end{cbox}
  \end{itemize}
\section{Debugging Tools}

\subsection{Tool: assert}

In major languages such as C, C++, Python, and Java, a mechanism called \tindex{assert} is provided for understanding programs and testing during execution.
The assert statement checks a conditional expression during program execution, and if it is true, does nothing; if it is false, it displays an error message and stops.

\paragraph{Code Example}
Calculation of factorial:
\begin{cbox}[emph={factorial}]
int factorial(int n) {
  if (n == 1)
    return 1;
  return n * factorial(n-1);
}
int main() {
  cout << factorial(3) << endl; // Outputs 3*2*1 = 6
  cout << factorial(-3) << endl; // If you accidentally enter a negative number, it won't stop
}
\end{cbox}

The above function works correctly only when the argument n is positive.
We want to ensure that the argument n is positive at runtime. To do this, include the cassert header and add an assert statement. As you can see, the content you want to guarantee is described as a conditional expression within the parentheses of assert.
\begin{cbox}[emph={cassert,assert}]
#include <cassert> // Added
int factorial(int n) {
  assert(n > 0); // Added
  if (n == 1)
    return 1;
  return n * factorial(n-1);
}
\end{cbox}

In this way, when writing a program based on some "premise," it is good to "assert" that in the source code for better clarity.

If you call \texttt{factorial(-1)} in this way, it will display an error and stop.

\begin{terminal}
Assertion failed: (n > 0), function factorial, file factorial.cc, line 3.
\end{terminal}

Since \texttt{assert} is a runtime test, it can cause a decrease in execution speed.
For this reason, a method is provided to easily disable all asserts without changing the source code.
For example, define the NDEBUG macro *before* including the cassert header, as follows:
\begin{cbox}[emph={NDEBUG}]
#ifndef NDEBUG
#  define NDEBUG
#endif
#include <cassert>
\end{cbox}

assert can also be used in Python. If you start with the option -O, such as \texttt{python3 -O}, the \texttt{assert} statement will be disabled.

\begin{pybox}[emph=assert]
def factorial(n):
    assert n >= 0
    if n == 0:
        return 1
    return n*factorial(n-1)
\end{pybox}

assert can also be used in Java.
\begin{javabox}[emph={Main,assert}]
public class Main {
    static int factorial(int n) {
	assert n >= 0;
	if (n == 0) return 1;
	return n*factorial(n-1);
    }
    public static void main(String[] args) {
	System.out.println(factorial(3));  // This will succeed
	System.out.println(factorial(-3)); // This will...
    }
}
\end{javabox}

In the case of Java, assert is enabled (only when it is added) by adding \texttt{-ea} as a runtime option.
\begin{terminal}
$ java -ea Main
6
Exception in thread "main" java.lang.AssertionError
	at Main.factorial(Main.java:3)
	at Main.main(Main.java:10)  
\end{terminal}
\subsection{Tool: -fsanitize}\label{section:cpp-sanitize}
In relatively new C++, compiler options such as \texttt{-fsanitize=undefined} and \texttt{-fsanitize=address} are available.
These options are useful when you have written an "incorrect program, but you don't know it, or you can't identify the location."

The function \texttt{fib} in the following program has a bug where it does not return a value when the argument \texttt{i==0}.
\begin{cbox}
#include <iostream>
using namespace std;
int fib(int i) {
  if (i == 1) return 1; // Forgot the case for i==0
  else if (i >= 2) return fib(i-1)+fib(i-2);
}
int main() {
  cout << fib(2) << endl;
}  
\end{cbox}

When the \texttt{-fsanitize=undefined} option is enabled as shown below, a runtime error is detected.
\begin{terminal}[emph={fsanitize,undefined}]
$ g++ -Wall fib.cc
$ ./a.out
2  
$ g++ -Wall -fsanitize=undefined fib.cc
$ ./a.out 
fib.cc:3:5: runtime error: execution reached the end of a value-returning function without returning a value
Abort trap: 6
\end{terminal}

The following (careless) program works correctly only when the integer read from the keyboard is between 0 and 3 inclusive.
\begin{cbox}
#include <iostream>
using namespace std;
int A[4] = {0,1,2,3};
int f(int idx) {
  return A[idx];
}
int main() {
  int idx;
  cin >> idx;
  cout << f(idx) << endl;
}
\end{cbox}

If you compile with \texttt{-fsanitize=undefined}, it will tell you that a violation occurred on line 5.
\begin{terminal}[emph={fsanitize,undefined}]
$ g++ -Wall -fsanitize=undefined test.cc
$ ./a.out 
|3|
3
$ ./a.out 
|8|
test.cc:5:10: runtime error: index 8 out of bounds for type 'int [4]'
\end{terminal}


\texttt{-fsanitize=undefined} is useful, but it is not a panacea.
Memory-related runtime errors can sometimes be found with \texttt{-fsanitize=address}.
The following program accesses an invalid address when \text{i=4}.
\begin{cbox}
#include <iostream>
using namespace std;
int A[4]={0,1,2,3};
int main() {
  int *p = A;
  for (int i=0; i<5; ++i) // 5 is a mistake for 4
    cout << *(p+i) << endl;
}  
\end{cbox}
Even if you use \texttt{-fsanitize=undefined}, this invalid memory access is not detected, and the program runs as if nothing happened.
\begin{terminal}[emph={fsanitize,undefined}]
$ g++ -Wall -fsanitize=undefined addr.cc 
$ ./a.out 
0
1
2
3
8842826
\end{terminal}

If you compile with \texttt{-fsanitize=address}, the invalid memory access is detected.
\begin{terminal}[emph={fsanitize,address}]
$ g++ -Wall -fsanitize=address addr.cc 
$ ./a.out 
0
1
2
3
=================================================================
==37898==ERROR: AddressSanitizer: global-buffer-overflow on address 0x000107f8d110 at pc 0x000107f8c8ea bp 0x7ffee7c74970 sp 0x7ffee7c74968
READ of size 4 at 0x000107f8d110 thread T0
    #0 0x107f8c8e9 in main (a.out:x86\_64+0x1000018e9)
    #1 0x7fff50332014 in start (libdyld.dylib:x86\_64+0x1014)
\end{terminal}
\subsection{Tool: \_GLIBCXX\_DEBUG (G++)}

In the case of G++, if you define \texttt{\_GLIBCXX\_DEBUG} at the beginning, it will find some mistakes.
(\url{http://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode_using.html#debug_mode.using.mode})

\begin{cbox}[emph={_GLIBCXX_DEBUG}]
#define _GLIBCXX_DEBUG
#include <vector>
using namespace std;
int main() {
    vector<int> a;
    a[0] = 3; // Violation of assigning to a vector of length 0
}
\end{cbox}

Execution example: (Instead of simply causing a segmentation fault, it tells you that it is out-of-bounds)
\begin{terminal}
/usr/include/c++/4.x/debug/vector:xxx:error: attempt to subscript container 
    with out-of-bounds index 0, but container only holds 0 elements.
\end{terminal}

\subsection{Tool: gdb}

Suppose you accidentally write a for loop that doesn't stop, like this:
\begin{cbox}
int main() { // Intending to repeat "hello" and "world" with newlines
  for (int i=0; i<10; ++i) {
    for (int j=0; j<2; ++i)
      cout << "hello " << endl;
    cout << "world" << endl;
  }
}
\end{cbox}

To prepare to use gdb, add the \texttt{-g} option to the compilation options.
\begin{terminal}[emph={g}]
$ g++ -g -Wall filename.cc
\end{terminal}

When executing, start gdb by giving it the name of the program to be debugged, and type run inside gdb.
\begin{terminal}[emph={gdb,a.out,run,bt,up,list,p}]
$ gdb ./a.out
(gdb starts)
(gdb) run # (Normal execution)
(gdb) run < sample-input.txt # (When using redirection)
# ...(The program executes)...
# ...(Stop by typing Ctrl-C or due to a segmentation fault, etc.)
(gdb) bt
(gdb) up // Go up to main a few times
(gdb) up
#12 0x080486ed in main () at for.cc:6
6	      cout << "hello " << endl;
(gdb) list
1	#include <iostream>
2	using namespace std;
3	int main() {
4	  for (int i=0; i<10; ++i) {
5	    for (int j=0; j<2; ++i)
6	      cout << "hello " << endl;
7	    cout << "world" << endl;
8	  }
9	}
(gdb) p i
$1 = 18047
(gdb) p j
$2 = 0
\end{terminal}

Main commands:
\begin{itemize}
\setlength{\itemsep}{0pt}
\item Display function call relationships: bt
\item Display the value of a variable: p variable name
\item Move one level up (to the caller): u
\item Display source code: list
\item Step execution: n, s
\item Continue execution: c
\item Exit gdb: q
\end{itemize}

You can also set breakpoints to interrupt execution when a specific location in the source code is reached, or when a variable's value is changed. See the manual for details.

\subsection{Tool: valgrind}

\begin{cbox}
int main() {
    int p; // Forgot initialization
    printf("
}  
\end{cbox}

Compile with the \texttt{-g} option, as when using gdb.
\begin{terminal}[emph={g}]
$ g++ -g -Wall filename.cc
\end{terminal}

When executing, give the executable program to the valgrind command.

\begin{terminal}[emph={valgrind,a.out}]
$ valgrind ./a.out
Conditional jump or move depends on uninitialised value(s)
...
\end{terminal}

\section{Sampling: Once You've Identified the Cause of a Bug}

Once you've identified the cause of a bug, sampling it can be used as an asset to reduce future debugging time. If you move on with "I'm lucky it worked," nothing will remain. Although it's off-topic, even in situations where you get stuck due to overlooking problem constraints or misunderstanding the meaning of the text, it would be helpful to collect patterns of misreading.

Array Boundaries
\begin{cbox}
    int array[3];
    printf("
\end{cbox}

Uninitialized Variables
\begin{cbox}
    int array[3];
    int main() {
      int a;
      printf("
    }  
\end{cbox}

Function without return
\begin{cbox}
int add(int a, int b) {
  a+b; // Correctly \cemph{return} a+b;
}
int main() {
  int a=1,b=2;
  int c=add(a,b); // The value of c is undefined
}
\end{cbox}

Stack Overflow
\begin{cbox}
  int main() {
    int a[100000000]; // It's better to move this to a global variable
  }
\end{cbox}

Invalid Pointer
\begin{cbox}
int *p;
*p = 1;  

char a[100];
double *b = &a[1];
*b = 1.0;
\end{cbox}

Required capacity for strings: A null terminator '\textbackslash{}0' is needed at the end
\begin{cbox}  
    char a[3]="abc"; // Correctly a[4] = "abc" or a[] = "abc"
    printf("
\end{cbox}

% A[i] (i is in the range $[0,N-1]$) trying to display in reverse order
\begin{cbox}
for (unsigned int i=N-1; i>0; ++i)
  cout << A[i] << endl;
\end{cbox}


% Want to read two integers
\begin{purecbox}
int a, b;
scanf("
\end{purecbox}
\begin{cbox}
int a, b;
cin >> a, b;
\end{cbox}


\chapter{Understanding Programming Languages and Environments}
\section{Loop Invariants}\label{chapter:loop-invariants}

Let's consider the correctness of a simple \texttt{for} statement like the following:

\begin{terminal}[emph={}]
def name(parameter1, parameter2...):
    variable = initial_value
    for ...
      variable = expression # Rewrite the variable to a new value
    return variable
\end{terminal}

Consider the following example problem and its solution.

\begin{psbox}{Sum of Consecutive Numbers (sum\_to\_n)}{no judge}
  Create a function \texttt{sum\_to\_n(n)} that calculates the sum of integers from 1 to $n$ by naively adding them. Assume $1<n$.
  (Verify with n=10000, etc.)
\end{psbox}

Example Solution:
\begin{pybox}
def sum_to_n(n):
    sum = 0
    for i in range(1, n+1):
        sum = sum + i
    return sum
\end{pybox}
Let's trace how such a program is derived.

If we were to calculate the sum up to a fixed value of 3, it could be written simply.
\begin{pybox}
def sum3():
    return 1+2+3
\end{pybox}
Using auxiliary variables $s_i$ (the sum from 0 to i), we can rewrite it into an equivalent program.
\begin{pybox}
def sum3():
    s0 = 0 # Sum of an empty set
    s1 = s0 + 1 # Sum of 1
    s2 = s1 + 2 # Sum of 1 and 2
    s3 = s2 + 3 # Sum of 1, 2, and 3
    return s3
\end{pybox}

Using assignment, we can also express the auxiliary variables $s_i$ with a single variable \texttt{sum}.
\begin{pybox}
def sum3():
    sum = 0 # sum is equivalent to s0
    sum = sum + 1 # The sum on the left is equivalent to s1, the sum on the right is equivalent to s0
    sum = sum + 2
    sum = sum + 3
    return sum # sum is equivalent to s3
\end{pybox}
The \texttt{for} loop version of this is the example solution at the beginning.

\begin{pybox}[emph=sum]
def sum_to_n(n):
    sum = 0
    for i in range(1, n+1):
        # (a) At this point, the value of sum is the sum from 0 to i-1
        sum = sum + i  # Note that sum += i is the same
        # (b) At this point, the value of sum is the sum from 0 to i
    return sum
\end{pybox}
Please confirm that the conditions regarding the value of sum described in comments (a) and (b) hold true at any point in the loop. Such conditions are called \texttt{loop invariants}.
Using these conditions regarding the value of sum, we can prove that the function calculates the sum up to n.

\section{Recursion}\label{section:recursion}

\subsection{Inductive Definitions and Linear Recursion}\label{section:linear}

Consider the situation of "wanting to calculate something repeatedly." There are two ways to write this: one is by using iteration or \textbf{loops} such as \texttt{while} or \texttt{for}, and the other is by using \tindex{recursion} where a function calls itself. Here, we will delve into the latter.

As an example, let's define a function equivalent to $1+2+\cdots+n$ using a \tindex{recurrence relation}.
If we write this function as $\mbox{sum}(n)$, it can be defined inductively as follows:
\[
        \mbox{sum}(n) = \left\{
        \begin{array}[c]{ll}
          1 & \mbox{when $n=1$}\\
          n + \mbox{sum}(n-1) & \mbox{otherwise}
        \end{array}
      \right.
\]
Note that sum itself is used within this definition.
This can be almost directly translated into Python or C++ definitions:
\begin{cbox}[emph={sum}]
int sum(int n) {
  if (n == 1) return 1;
  else return n + sum(n-1);
}
\end{cbox}
\begin{textblock}{3}(4,-1.2)
\begin{shaded*}
\noindent
The \textcolor{ired}{sum} in red is the recursive structure.
\end{shaded*}
\end{textblock}
\begin{pybox}[emph={sum1}]
def sum1(n):
    if n == 1:
        return 1
    else:
        return n + sum1(n-1)
\end{pybox}

\paragraph{Understanding Program Correctness} It is good to confirm the following two points:
\begin{itemize}
\item Confirm the correctness of the base case: when $n=1$, \texttt{sum1(n)}$=1$
\item Assuming correctness up to $n-1$, confirm the correctness for $n$: \texttt{sum1(n)}$=n+$\texttt{sum1(n-1)}
\end{itemize}

\subsection{Recursion with Branching}\label{section:branching}
In the recursive calls we have seen so far, a function called itself only once. From now on, we will deal with cases where multiple recursive calls are made.


\begin{psbox}{Fibonacci Numbers}{no judge}
The Fibonacci sequence (\eindex{Fibonacci numbers}) is a sequence of numbers formed by "the sum of the previous two numbers," such as
\[
        0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots
\]
Inductively define the $n$-th Fibonacci number $\mathit{fib}(n)$.
Also, define the function \texttt{fib(n)}.
\end{psbox}

\begin{pybox}
def fib(n):
    print("fib",n) # Display the argument when the function is called
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-2)+fib(n-1)
\end{pybox}

Note that recursion is not the best way to calculate Fibonacci numbers. More efficient ways to find Fibonacci numbers will be discussed separately.


\paragraph{Tail Recursion}

Consider the following definition of $\mbox{sum}'(s,n)$, which is a slight modification of the formula:
\[
        \mbox{sum}'(s,n) = \left\{
        \begin{array}[c]{ll}
          s+1 & \mbox{when $n=1$}\\
          \mbox{sum}'(s+n, n-1) & \mbox{otherwise}
        \end{array}
      \right.
\]
Considering $s$ in the above definition as "the sum so far," confirm that $\mbox{sum}(n) = \mbox{sum}'(0,n)$.


\begin{pybox}[emph={sum2}]
def sum2(s,n):
    if n == 1:
        return s+1
    else:
        return sum2(s+n, n-1)
\end{pybox}

A structure where a function calls itself as its return value is called \jindex{tail recursion}{tail recursion}. Writing it this way has the advantage that it is easier for the compiler to optimize.

Also, introducing auxiliary variables like $s$ can sometimes improve the clarity of recursion.





\begin{tipsbox}{maximum recursion depth exceeded}
Recursive functions must be implemented to stop somewhere. For example, the following function does not have a defined stopping point.
\begin{pybox}
def inf(a):
    return 1+inf(a)
\end{pybox}
If you call this function as \texttt{inf(0)},
\begin{terminal}[name=RecursionError]
>>> inf(0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in inf
  File "<stdin>", line 2, in inf
  File "<stdin>", line 2, in inf
  [Previous line repeated 995 more times]
RecursionError: maximum recursion depth exceeded
\end{terminal}
you will see an error message indicating that the process could not continue due to \texttt{RecursionError: maximum recursion depth exceeded}.

\end{tipsbox}

\medskip

\paragraph{Recursive Thinking about Operations}
As an example, consider the operation \texttt{print\_range(n)} that displays integers from 1 to n. Similar to the previous \texttt{sum}, the operation can be defined as follows:
\[
        \mbox{\cemph{print\_range}}(n) = \left\{
        \begin{array}[c]{ll}
          \text{Display } 1 & \mbox{when $n=1$}\\
          \mbox{\cemph{print\_range}}(n-1) \; \langle\text{afterward}\rangle
          \; \text{Display } n & \mbox{otherwise}
        \end{array}
      \right.
\]

\begin{pybox}[emph={print_range}]
def print_range(n):
  if n == 1:
    print(1)
  else:
    print_range(n-1)
    print(n)
\end{pybox}


\begin{psbox}{m-ary Numbers}{no judge}
  Given integers m and n ($1\le n \le
  8$, $1 < m \le 10$).
  Create a function \texttt{mdigit(m,n)} that displays all n-digit m-ary numbers in ascending order.
\end{psbox}

\begin{terminal}
>>> mdigit(3,2)
00
01
02
10
11
12
20
21
22
\end{terminal}

For simplicity, consider $m=2$, i.e., binary numbers. For a positive integer $n$, we want to construct a procedure that achieves the goal based on a procedure that performs the same process for $n-1$.
In other words, assuming someone has created a function that displays all $n-1$ digit binary numbers (*1), can we create a function that displays all $n$ digit $m$-ary numbers based on that?

An $n$-digit binary number can be decomposed into the leftmost digit ($0$ or $1$) and the remaining $n-1$ digits.
Therefore, we want to do something like: display all $n-1$ digit binary numbers with \emph{0 added to the left}, and display all $n-1$ digit binary numbers with \emph{1 added to the left}.

Based on the above, by slightly adjusting the function (*1), add the string prefix that you want to be written on the left as an argument, and let \texttt{B}(prefix, n) be a function that "generates all n-digit binary numbers for the argument prefix and n, and displays each with the prefix attached."

\begin{equation}
  \texttt{B}(\text{prefix},n) = \left\{
  \begin{array}{ll}
    \text{Display prefix} & (n=0)\\
    \text{Execute } \texttt{B}(\text{prefix} + 0, n-1) \text{ and}\\
    \texttt{ B}(\text{prefix} + 1, n-1) & (n>1)
  \end{array}\right.\label{eq:rec-mn}
\end{equation}

\begin{center}
  \newcolumntype{G}{>{\columncolor[gray]{0.8}}c}
  \newcommand{\gr}[1]{\textcolor{gray}{#1}}
  \begin{tabular}{ll}
    \begin{minipage}{.4\linewidth}
      \begin{tabular}{Gcc}
        \multicolumn{1}{c}{prefix} & 3 & 2,1\\\hline
  10&0&\tikzmark{recmn0}\cellcolor{blue!10}00\\
  \gr{10}&\gr{0}&\cellcolor{blue!10}01\\
  \gr{10}&\gr{0}&\cellcolor{blue!10}10\\
  \gr{10}&\gr{0}&\cellcolor{blue!10}11\\\hdashline
  \gr{10}&1&\tikzmark{recmn1}\cellcolor{green!10}00\\
  \gr{10}&\gr{1} &\cellcolor{green!10}01\\
  \gr{10}&\gr{1} &\cellcolor{green!10}10\\
  \gr{10}&\gr{1} &\cellcolor{green!10}11
\end{tabular}
    \end{minipage}
    &
    \begin{minipage}{.2\linewidth}
\begin{tikzpicture}[remember picture,overlay]
\draw [dotted] (pic cs:recmn1) rectangle (pic cs:recmn1)+(1em,.7ex);


\draw[<-] ([xshift=2em]pic cs:recmn0) -- ++(0:5em) coordinate (aux0);
\node[right] at (aux0) {Realized through B(100,2)};

\draw[<-] ([xshift=2em]pic cs:recmn1) -- ++(0:5em) coordinate (aux1);
\node[right] at (aux1) {Realized through B(101,2)};

\end{tikzpicture}
    \end{minipage}
  \end{tabular}\\
\texttt{Operation of B(10,3): B(100,2) and B(101,2)}
\end{center}


Confirm that \texttt{B(0,n)} displays all $n$-digit binary numbers. To handle not only binary numbers but also $m$-ary numbers, the part that was branching only with $0$ and $1$ should be branched from $0$ to $m-1$ using a \texttt{for} statement or similar.

Although the prefix was explained assuming a string (\texttt{str}), it can also be represented with \texttt{int}. In that case, for example, the operation of adding 1 to the right of the prefix would be \texttt{prefix*10+1}.

Syntax: In Python, to display an integer a with N digits, padding with 0s when the number of digits is insufficient, do the following:
\begin{pybox}
>>> print("{:05d}".format(3))
00003
\end{pybox}
\subsection{Function and Execution State Management}\label{section:stackframe}

Let's supplement the "relationship between statements being executed from top to bottom and recursive calls."

\paragraph{Normal Function Call Case}

Although somewhat contrived, let's assume there is the following source code. When the function \texttt{helloworld} is executed, \texttt{hello} and \texttt{world} are displayed line by line.
\begin{pybox}
def mynewline():
    print("")

def myprint(msg): # Writes a message and adds a newline
    print(msg, end="")
    mynewline()

def helloworld():
    myprint("hello")
    myprint("world")
\end{pybox}

A schematic representation of a part of this execution process is as follows.
In many programming languages, including C++, when a function is called, a \tindex{frame} is created to manage the execution state and local variables of that function. In the figure below, frames are represented by boxes.

\begin{tabular}{lll}
  \begin{minipage}{.3\linewidth}
  \begin{itembox}[l]{helloworld()}
    \begin{alltt}
myprint("hello")\tikzmark{callhello}
myprint("world")\tikzmark{callworld}
\end{alltt}
  \end{itembox}
  \end{minipage}
&
  \begin{minipage}{.3\linewidth}
  \begin{itembox}[l]{\tikzmark{hello}myprint(msg=hello)}
    \begin{alltt}
print(msg, end="")
\tikzmark{mpend}mynewline()\tikzmark{callnl}
\end{alltt}
  \end{itembox}
  \end{minipage}
&
  \begin{minipage}{.3\linewidth}
  \begin{itembox}[l]{\tikzmark{nl}mynewline()}
    \begin{alltt}
\tikzmark{nlend}print("")
\end{alltt}
  \end{itembox}
  \end{minipage}
\\
&
  \begin{minipage}{.3\linewidth}
  \begin{itembox}[l]{\tikzmark{world}myprint(msg=world)}
    \begin{alltt}
print(msg, end="")
mynewline()
\end{alltt}
  \end{itembox}
  \end{minipage}
&
\end{tabular}

\begin{tikzpicture}[remember picture]
\draw[->,overlay,ultra thick,iblue,bend left=20,yshift=5](pic cs:callhello) to node[above,iblue] {(1)} (pic cs:hello);
\draw[->,overlay,ultra thick,iblue,bend left=20,yshift=5](pic
cs:callnl) to node[left,iblue] {(2)} (pic cs:nl);
\draw[->,overlay,ultra thick,dotted,iblue,bend left=20,yshift=-5](pic cs:nlend) to node[above,iblue] {(3)} (pic cs:callnl);
\draw[->,overlay,ultra thick,dotted,iblue,yshift=-5](pic cs:mpend) to node[above left,iblue] {(4)} (pic cs:callhello);
\draw[->,overlay,ultra thick,iblue,bend right=20](pic cs:callworld) to node[below,iblue] {(5)} (pic cs:world);
\end{tikzpicture}

When viewed within each frame, statements are executed in the order they are written. For example, in the leftmost \texttt{helloworld} frame, the execution of \texttt{myprint("hello")} is completed before the execution of \texttt{myprint("world")} begins.
The completion of the execution of \texttt{myprint("hello")} means that the call to the \texttt{myprint} function is executed (arrow (1)), and within that frame, the execution of all statements is completed and control is returned (arrow (4)). In that process, the \texttt{mynewline} function is also executed (arrows (2), (3)).
As shown by arrows (3) and (4), when the execution of all statements in a frame is completed or a \texttt{return} occurs, control is returned to the appropriate location in the caller.

\paragraph{Recursive Case} Similarly, in the case of recursion, a frame is created for each call.
Suppose the m-ary number example from Section \ref{section:branching} is implemented as follows:

\begin{pybox}[emph={B}]
def B(prefix, n):
    if (n==0):
        ...
        return
    B(prefix+"0", n-1)
    B(prefix+"1", n-1)
\end{pybox}

At this time, the call to \texttt{B("",3)} proceeds as follows:

\begin{tabular}{@{}llll@{}}
  \begin{minipage}{.2\linewidth}
  \begin{itembox}[l]{B("", n=3)}
    \begin{alltt}
B(""+"0",2)\tikzmark{callB02}
B(""+"1",2)
\end{alltt}
  \end{itembox}
  \end{minipage}
&
  \begin{minipage}{.21\linewidth}
  \begin{itembox}[l]{\tikzmark{B02}B("0", n=2)}
    \begin{alltt}
B("0"+"0",1)\tikzmark{callB001}
B("0"+"1",1)
\end{alltt}
  \end{itembox}
  \end{minipage}
&
  \begin{minipage}{.23\linewidth}
  \begin{itembox}[l]{\tikzmark{B001}B("00", n=1)}
    \begin{alltt}
B("00"+"0",0)\tikzmark{callB0000}
B("00"+"1",0)\tikzmark{callB0010}
\end{alltt}
  \end{itembox}
  \end{minipage}
&
  \begin{minipage}{.23\linewidth}
  \begin{itembox}[l]{\tikzmark{B0000}B("000", n=0)}
    \begin{alltt}
\tikzmark{B0000end}if (n==0) ...
\end{alltt}
  \end{itembox}
  \begin{itembox}[l]{\tikzmark{B0010}B("001", n=0)}
    \begin{alltt}
if (n==0) ...
\end{alltt}
  \end{itembox}
  \end{minipage}
\end{tabular}

\begin{tikzpicture}[remember picture]
\draw[->,overlay,ultra thick,iblue,bend left=20,yshift=5](pic cs:callB02) to node[above,iblue] {(1)} (pic cs:B02);
\draw[->,overlay,ultra thick,iblue,bend left=20,yshift=5](pic
cs:callB001) to node[above,iblue] {(2)} (pic cs:B001);
\draw[->,overlay,ultra thick,iblue,bend left=20,yshift=5](pic
cs:callB0000) to node[above,iblue] {(3)} (pic cs:B0000);
\draw[->,overlay,ultra thick,dotted,iblue,yshift=-5](pic
cs:B0000end) to node[above,iblue] {(4)} (pic cs:callB0000);
\draw[->,overlay,ultra thick,iblue,bend right=20,yshift=5](pic
cs:callB0010) to node[below,iblue] {(5)} (pic cs:B0010);
\end{tikzpicture}

Note that even if it is the same function in the source code, a different frame is created for each call.
Each frame maintains information such as arguments, local variables, and how far the execution has progressed.
A \tindex{stack area} is used to manage such information (different from the stack data structure).
Frames that have completed execution are discarded, but frames that have not completed need to be maintained in memory. Therefore, calling a function many times (e.g., 1 million times) may result in a runtime error. For example, in the standard exercise environment, the limit is 8 megabytes. \index{ulimit}
\begin{terminal}
ssh0-01m:~ 0123456789$ ulimit -a
...
stack size              (kbytes, -s) 8192
...
\end{terminal}
\section{Understanding Integer Types}\label{section:long-long}

In this material, we will use the \texttt{int} and \texttt{long long} types as needed to represent integers. There is a difference in the range of numbers that can be represented by each.

\begin{cbox}
    long long a = 1000000;
    int b = 1000000;
    cout << a * a << endl; // 1000000000000
    cout << b * b << endl; // -727379968 (overflow)
\end{cbox}

Usually, in C++, integers are represented by variables of type \texttt{int}. However, in the iMac environment of this exercise, as shown in Table \ref{table:nlimits}, the range of values that can be represented by the \texttt{int} type and other integer types is limited.

In the previous example,
$$1\,000\,000 \cdot 1\,000\,000 = 10^{12} > 2^{31} \approx 2\cdot10^{9}$$
exceeds the range that can be represented by a 32-bit integer.
Therefore, in such cases, it is necessary to use the \eindex{long long} type. One of the goals is to be able to grasp this \cemph{before starting to write the program}. \footnote{It is recommended to memorize $2^{10}=1\,024\approx10^3$ in order to perform such calculations smoothly.}

\begin{table}
  \centering
  \caption{Representation of signed integers in the environment assumed by this material}
  \label{table:nlimits}
  \begin{tabular}{l|rrrl}\hline
    type & bits & Lower Limit & Upper Limit & Notes\\\hline
    \cemphtt{int} & $32$ & $-2^{31}$ & $2^{31}-1$ & Approximately 2 billion\\
    \texttt{long} & $32/64$ & & & Not recommended for use\\
    \cemphtt{long long} & $64$ & $-2^{63}$ & $2^{63}-1$ & Standard type since C++11, previously a gcc extension\\
    \texttt{\_\_int128\_t} & 128 & & & gcc extension, not portable but powerful\\\hline
  \end{tabular}
\end{table}

The range that can be represented by each type may vary depending on the environment. You can check the environment you are using with the following program. The syntax of \texttt{numeric\_limits} is omitted, but those who are interested should investigate template classes and standard libraries \cite{book:cpp}.
\begin{cbox}[emph={limits}]
#include <limits>
#include <iostream>
using namespace std;
int main() {
  cout << sizeof(int) // Number of bytes
       <<' '<< numeric_limits<int>::digits // Number of bits excluding sign
       <<' '<< numeric_limits<int>::digits10 // Number of decimal digits
       <<' '<< numeric_limits<int>::min()
       <<' '<< numeric_limits<int>::max()
       << endl;
  cout << sizeof(long long)
       <<' '<< numeric_limits<long long>::digits
       <<' '<< numeric_limits<long long>::digits10
       <<' '<< numeric_limits<long long>::min()
       <<' '<< numeric_limits<long long>::max()
       << endl;
}  
\end{cbox}
\begin{terminal}
$ ./a.out
4 31 9 -2147483648 2147483647
8 63 18 -9223372036854775808 9223372036854775807  
\end{terminal}

Note that Table \ref{table:nlimits} only lists \jindex{signed integers}{signed integers}. \jindex{Unsigned integers}{unsigned integers} (\tindex{unsigned}\texttt{ int}, \texttt{unsigned long long}, etc.) cannot represent negative numbers, but can represent positive numbers in a range about twice as large. Although they are hardly used in this material, please understand them as needed.
In C++11, by using \texttt{\#include<cstdint>}, types such as \eindex{int32\_t} and \eindex{int64\_t} can be used. In the future, these should be used, but in this material, we will use \texttt{int} and \texttt{long long}.
\section{Floating-Point Numbers and Errors}\label{section:floating-point-numbers}

When dealing with real numbers, floating-point numbers are usually used.

However, depending on the situation, it may be appropriate to use integers to represent decimal numbers. For example, if you only need to handle up to two decimal places (like yen and sen), you can multiply the number by 100 to make it an integer. In that case, you can perform calculations internally as integers and only convert to decimal notation when displaying, such as with \texttt{cout << x/100 << "." << (x\%100) << endl;}. (Fixed-point)

To flexibly represent larger or smaller numbers, a real number representation (floating-point representation) with a \emph{sign part}, an \emph{exponent part}, and a \emph{mantissa part} is used.

\subsection{Various Errors}
When using floating-point numbers, it is necessary to understand that they involve errors.

Errors are not always intuitive.
As an example, consider a loop that processes from 0 to 1 in increments of 0.1.
In this case, the appropriate method is to use an integer for the loop counter. Even if they seem equivalent, the method of adding 0.1 each time can lead to unexpected results.

\begin{center}
\begin{tabular}{ll}\hline
  \begin{minipage}{.4\linewidth}
Good Implementation
\begin{pybox}
i = 0
while i < 10:
  print(i/10.0)
  i += 1
\end{pybox}    
  \end{minipage}
  &
  \begin{minipage}{.5\linewidth}
\begin{alltt}
0.0
0.1
(omitted)
0.8
0.9  # Total of 10 lines
\end{alltt}
  \end{minipage}
  \\\hline
  \begin{minipage}{.4\linewidth}
Bad Implementation
(Displays 11 lines from 0.1...)
\begin{pybox}
i = 0.0
while i < 1.0:
  print(i)
  i += 0.1
\end{pybox}
  \end{minipage}
  &
  \begin{minipage}{.5\linewidth}
\begin{alltt}
0.0
0.1
(omitted)
0.7999999999999999
0.8999999999999999
0.9999999999999999     # Total of 11 lines
\end{alltt}
  \end{minipage}
\\\hline\end{tabular}
\end{center}

Such phenomena arise from rounding errors, which will be explained next.
Furthermore, errors can increase in operations between numbers that already contain errors. There are four types of errors, classified as follows:

\begin{description}
\item[Round-off errors] Errors caused by the fact that decimal numbers can only be represented approximately with a finite number of digits when expressed in binary (equivalent to the fact that 1/3 cannot be accurately represented with a finite number of digits in decimal notation).
  \\
  Example: $0.1_{(10)} = 2^{-4} + 2^{-5}+2^{-8}+2^{-9}\ldots =
  1.10011\ldots_{(2)}\cdot 2^{-4}$\\
  Exercise: Predict the output of the following program?
  \begin{cbox}
#include <iostream>
using namespace std;
int main() {
  double a = 0.1;
  double b = 0.3;
  if (a*3 == b) cout << "OK" << endl;
  else cout << "NG" << endl;
}    
  \end{cbox}
  \begin{terminal}
0.1*3 = 0011111111010011001100110011001100110011001100110011001100110100
  0.3 = 0011111111010011001100110011001100110011001100110011001100110011    
  \end{terminal}
\item[Loss of significance] When taking the difference between two nearly identical numbers \emph{represented with a finite number of significant digits}, the number of significant digits decreases.
  \\
  Example: $0.124 - 0.123 = 0.001$\\
Note: This does not occur in operations between numbers that are originally represented without error.
\item[Information loss] In addition or subtraction of numbers with different magnitudes, the smaller number is ignored because it falls outside the significant range of the larger number.
  \\
  Example: $0.124 + 0.0000000123 = 0.124$
\item[Truncation errors] When numerically calculating the value of a function using an infinite series, errors occur due to approximating by truncating at a finite number of terms.
\end{description}

\subsection{Understanding the \texttt{double} Type}
In IEEE 754 double-precision (64-bit) floating-point format, a number is represented by a combination of three integers: the sign part $s$, the exponent part $e$, and the mantissa part $m$, as follows:
\begin{equation}
(-1)^s (1+m \cdot 2^{-52})) \cdot 2^{(e-1023)}.\label{eq:ieee64}
\end{equation}
The entire representation uses 64 bits, with the sign part $s$ occupying bit 0, the exponent part $e$ occupying bits 1-11 (11 bits), and the mantissa part $m$ occupying bits 12-63 (52 bits).

The following program uses the \texttt{union} feature to display the internal representation of a \texttt{double} type. Note that \texttt{bitset} is used here only to obtain the binary representation of an integer.

\begin{cbox}
#include <iostream>
#include <bitset>
using namespace std;
union double_long_long {
  double floating_value;
  unsigned long long integer_value;
};
void show_double(double v) {
  double_long_long u;
  u.floating_value = v;
  cout << v << " = " << bitset<64>(u.integer_value) << endl;
  long long sign = u.integer_value >> 63;
  long long exponent = (u.integer_value >> 52)& ((1<<11)-1);
  long long mantissa = u.integer_value & ((1ul<<52)-1);
  cout << " sign = " << sign << endl;
  cout << " exponent = " << exponent << ' ' << bitset<11>(exponent) << endl;
  cout << " mantissa = " << bitset<52>(mantissa) << endl;
  cout << " => " << (sign ? "-" : "+")
       << " (1+" << (double)mantissa/(1ul<<52)
       << ") * " << "2^(" << (exponent-1023) << ")" << endl;
}
int main() {
  show_double(1.0);
  show_double(-1.0);
  show_double(0.5);
  show_double(0.25);
  show_double(0.75);
}
\end{cbox}

Execution Example: Verify against Equation \ref{eq:ieee64}.
\begin{terminal}
1 = 0011111111110000000000000000000000000000000000000000(omitted)
 sign = 0
 exponent = 1023 01111111111
 mantissa = 000000000000000000000000000000000000000000(omitted)
 => + (1+0) * 2^(0)
-1 = 101111111111000000000000000000000000000000000000000(omitted)
 sign = 1
 exponent = 1023 01111111111
 mantissa = 000000000000000000000000000000000000000000(omitted)
 => - (1+0) * 2^(0)
0.5 = 00111111111000000000000000000000000000000000000000(omitted)
 sign = 0
 exponent = 1022 01111111110
 mantissa = 000000000000000000000000000000000000000000(omitted)
 => + (1+0) * 2^(-1)
0.25 = 0011111111010000000000000000000000000000000000000(omitted)
 sign = 0
 exponent = 1021 01111111101
 mantissa = 000000000000000000000000000000000000000000(omitted)
 => + (1+0) * 2^(-2)
0.75 = 0011111111101000000000000000000000000000000000000(omitted)
 sign = 0
 exponent = 1022 01111111110
 mantissa = 100000000000000000000000000(omitted)
 => + (1+0.5) * 2^(-1)
\end{terminal}

Exercise: Predict the bit string when 0.875 ($1/2+1/4+1/8$) is represented as a \texttt{double}. Verify using the program above.
\section{Structures: struct}\label{section:struct}

The \tindex{struct} is used to manage data collectively. With the following syntax, a new type called \texttt{Student} with integer variables \texttt{height} and \texttt{weight} is defined:
\begin{cbox}[emph=Student]
struct Student {
  int height, weight;
};
\end{cbox}

Example of use:
\begin{cbox}[emph=Student]
  Student a;
  a.height = 150;
  a.weight = 50;
  cout << a.height << ' ' << a.weight << endl;

  Student b = { 170, 70 };
  cout << b.height << ' ' << b.weight << endl;

  Student c = { 180 }; // weight == 0
  Student d = { };  // height, weight == 0
\end{cbox}
\begin{itemize}
\item To access the \texttt{height} or \texttt{weight} of each variable of type Student (in the above, \texttt{a, b, c, d}), use the \texttt{.} (dot) operator.
\item Initialization can also be done with curly braces \texttt{\{\}}.
\end{itemize}

\chapter{Ruby}\label{chapter:ruby}

\section{Input and Output}
This section mainly introduces sample code related to Chapter \ref{chapter:io}.

\subsection{ICPC Score Totalizer Software}
\begin{rbox}
while true
  judges = gets.to_i # Input a number
  break if judges == 0
  a = [] 
  for i in 0..judges-1
    a << gets.to_i
  end # By this point, the scores of each judge are in array a
  sum = 0
  for i in 0..judges-1
    sum = sum + a[i]
  end
  puts sum
  puts a.max
end
\end{rbox}

\subsection{Array Operations}

\begin{rbox}[emph={Array}]
  n = 50
  # Prepare an array of length n and initialize each element to 0 (valid from a[0] to a[n-1])
  a = Array.new(n,0)
\end{rbox}


\begin{rbox}[emph={each}]
a = Array.new(5)
a.each{|e| puts e}
\end{rbox}

\begin{rbox}
a = [3,5,1,2,4]
a.sort!
a.reverse! # Reverse the order of a
p a
\end{rbox}

\begin{rbox}
a = [0,1,2,3,4,5,6]
a[0,7] = a[3,4]+a[0,3]
p a # \dingright{} [3, 4, 5, 6, 0, 1, 2]
\end{rbox}

\subsection{Hanafuda Shuffle}
\begin{rbox}
while line = gets
  n, r = line.split(" ").map{|i| i.to_i} # Read n and r
  break if n == 0
  # Create a deck of n cards
  # Try displaying the created deck
  r.times {
    p, c = gets.split(" ").map{|i| i.to_i}
    # Perform shuffle p, c
    # Try displaying the entire deck after each shuffle
  }
  # Output the top of the deck
end
\end{rbox}

\section{Sorting and Greedy Algorithms}
This section mainly introduces sample code related to Chapter \ref{chapter:greedy}.

\subsection{Sorting}
\begin{rbox}
a = [3,5,1,2,4]
a.sort!
p a
\end{rbox}
\subsection{Finding Minimum String}

\begin{rbox}
N = gets.to_i
A = []
(1..N).each {
  A << gets.chomp 
}
... // Sort A as with integers
puts A[0]
\end{rbox}
\subsection{Pairs and Sorting}

\begin{rbox}
a = [3,5]
p a # Displays [3,5]
b = [0.5,"X"]
p b # Displays [0.5,"X"]
\end{rbox}

\subsection{Princess's Marriage}
\begin{rbox}
while line = gets
  pN, pM = line.split(" ").map{|s| s.to_i}
  break if pN == 0
  pd = [] # Array to store <p,d>
  (1..pN).each { # Do something pN times
    d, p = gets.split(" ").map{|s| s.to_i}
    pd << [p, d] 
  }
  # Try sorting pd in descending order
  # Try outputting pd
  # If the sorting is successful, try calculating the answer
end  
\end{rbox}

\section{Dynamic Programming}
This section mainly introduces sample code related to Chapter \ref{chapter:dp}.

\subsection{Naive Calculation of Fibonacci Numbers}
\begin{rbox}
def fib(n) # Slow version
  # p ["fib",n] Display the argument when the function is called
  if n==0
    0
  elsif n == 1
    1
  else
    fib(n-2)+fib(n-1)
  end
end  
\end{rbox}

\subsection{Heian-kyo Walking}

Input Example
\begin{rbox}
dataset = gets.to_i
dataset.times {
  gx, gy = gets.split(" ").map(&:to_i)
  p [gx,gy]
  matatabi = gets.to_i
  # In the problem statement, variable p is used, but it is separated from the display command p
  (0..matatabi-1).each{|i|
    x1,y1, x2,y2 = gets.split(" ").map(&:to_i)
    p [x1,y1, x2,y2]
  }
}  
\end{rbox}

\section{Basic Data Structures}
This section mainly introduces sample code related to Chapter \ref{chapter:datastructure}.

\subsection{Strings and Reading}
\begin{rbox}
word = gets.chomp # Reads a line with gets and removes the newline character at the end with chomp
puts word+word # Displays the concatenated string
\end{rbox}

\subsection{Stack}

In Ruby, we will use \texttt{unshift, shift} as \texttt{push, pop} respectively.
\begin{rbox}[emph={unshift,shift}]
stack = [] # (Treating an array as a Stack)
stack.unshift(3) # Add an element to the beginning
stack.unshift(4)
stack.unshift(1)
while stack.size > 0 # While there are elements
  n = stack.shift # Remove from the beginning
  p n
end  
\end{rbox}


In Ruby, it is convenient to treat an array as a queue.
\begin{rbox}[emph={shift}]
Q = [] # (Treating an array as a Queue)
Q << 3 # Add an element to the end
Q << 4
Q << 1
while Q.size > 0 # While there are elements
  n = Q.shift # Remove from the beginning
  p n
end
# 3, 4, 1 are displayed in this order
\end{rbox}

\subsection{Priority Queue}

In the case of Ruby, it seems that there are currently no libraries available for online judges, so it is necessary to implement a binary heap or similar yourself.
\begin{rbox}[emph={PriorityQueue,push,pop,size}]
class PriorityQueue
  def initialize
    # Implement a binary tree with an array. The left child of the i-th element is 2i+1, and the right child is 2i+2.
    # The parent element is assumed to have a higher priority than either of its children.
    @array = [] 
    @size = 0
  end
  def push(a)
    # After temporarily placing it at the end, move it up if its priority is higher than its ancestors.
    @array[@size] = a
    heapify_up(@size)
    @size += 1
  end
  def pop()
    # After taking out the root element (highest priority), temporarily place the last element at the root and adjust.
    raise unless @size > 0
    ans = @array[0]
    @size -= 1
    @array[0] = @array[@size]
    heapify_down(0)
    ans
  end
  def size
    @size
  end
  def swap(p,q) 
    @array[p],  @array[q] = @array[q], @array[p]
  end
  def equal_or_better(p,q)
    (@array[p] <=> @array[q]) <= 0
  end
  def heapify_up(n)
    while n > 0
      parent = (n-1)/2
      break if equal_or_better(parent, n)
      swap(parent,n)
      n = parent
    end
  end
  def heapify_down(n)
    while true
      l, r = n*2+1, n*2+2
      break if @size <= l
      child = l
      child = r if r < @size && equal_or_better(r, l)
      break if equal_or_better(n, child)
      swap(child, n)
      n = child
    end
  end
end

Q = PriorityQueue.new
Q.push([50, 1]);
Q.push([20, 2]);
Q.push([30, 3]);
Q.push([10, 4]);
Q.push([80, 5]);

while Q.size() > 0
  cur = Q.pop(); # Extract the smallest element
  p cur
end
\end{rbox}
\subsection{Strings and Splitting, Joining, Reversing}

\begin{rbox}
word = "hello"
s = word.split("")
(0..s.length).each {|l|
  a = s.first(l)
  b = s.last(s.length-l)
  # p a
  # p b
  puts a.join("")+" "+b.join("")
}  
\end{rbox}

\begin{rbox}
a = "hello"
b = a.reverse
puts b
\end{rbox}

\subsection{Sets}

In Ruby, you can achieve similar functionality using \texttt{Hash}.\footnote{Sets are also available, and you can use them by writing \texttt{require 'set'}, so those who are interested should investigate.}
For insertion, use \texttt{a[element]=1} instead of \texttt{a.insert(element)}; for the number or presence of a specified element, use \texttt{a[element]} instead of \texttt{a.count(element)}; and for the number of elements in the set, use \texttt{a.length} instead of \texttt{a.size()}.

\begin{rbox}
all = Hash.new(0)
puts all.length # 0
all["hello"] = 1
all["world"] = 1
all["good morning"] = 1
all["world"] = 1
puts all["world"] # 1
puts all["hello!!!"] # 0
puts all.length # 3
\end{rbox}

\subsection{Associative Arrays}

\begin{rbox}[emph={Hash}]
table = Hash.new(0) # Specified the value to be 0 when the key does not exist (*)
table["taro"] = 180
table["hanako"] = 160
puts table["taro"] # 180
puts table["ichirou"] # 0 (*)
\end{rbox}

\begin{rbox}
table["ichirou"] += 1
puts table["ichirou"] # 1
table["ichirou"] += 1
puts table["ichirou"] # 2
\end{rbox}


\begin{rbox}
phone = Hash.new
phone["taro"] = 123;
phone["jiro"] = 456;
phone["saburo"] = 789;

phone.each{|key,value|
  p [key, value]
}
# ["taro", 123]
# ["jiro", 456]
# ["saburo", 789]
\end{rbox}

In the case of Ruby, a more concise notation than C++ is possible. Specify the variables you want to use in the loop in the \texttt{|key,value|} part.

\section{Graph Traversal}
This section mainly introduces sample code related to Chapter \ref{section:graphsearch}.

Reading an Adjacency List (Example Graph)
\begin{rbox}
N = gets.to_i
G = (1..N).map{ Array.new(N, 0) }
N.times{
  u,k,*v = gets.split(' ').map(&:to_i) # u,k are numbers, v is an array
  v.each {|vi| # For each element vi in v
    # Connect (u-1) and (vi-1)
  }
}
G.each{|r|
  puts r.join(' ')
}
\end{rbox}

Breadth-First Search (BFS) (Chapter \ref{section:bfs})
\begin{rbox}
Q = [0] # Queue (array) with starting point 0
D = Array.new(N,-1)
D[0] = 0 # Distance to the starting point is 0, other distances are -1
while Q.size > 0
  p ["debug", Q] # Check the operation of Q at each step (remove later)
  cur = Q.shift
  (0..N-1).each {|dst|
    if ... then # If it is possible to move from cur to dst, and dst is unvisited \label{code:dfsruby:visit}
      D[dst] = D[cur]+1
      Q << dst # Push dst onto Q
    end
  }
end
# Display D
\end{rbox}

Depth-First Search (DFS) (Chapter \ref{section:dfs})
\begin{rbox}[emph={dfs}]
def dfs(src)
  D[src] = $time # Record the visit time
  $time += 1
  (0..N-1).each {|dst|
    if ... then # If it is possible to move from src to dst, and dst is unvisited
      dfs(dst)
    end
  }
  F[src] = $time # Record the finish time
  $time += 1
  # At the end of the function, \textcolor{iblue}{\textbf{return to the parent (blue arrow)}}
end


D = Array.new(N) # Initial value of D[i] is nil
F = Array.new(N)
$time = 1

(0..N-1).each {|id| # From the node with the smallest number
  if ! D[id] then # If D[id] is unvisited
    dfs(id) # Start dfs
  end
}
# Output
\end{rbox}

\section{Shortest Paths}
This section mainly introduces sample code related to Chapter \ref{chapter:shortestpath}.

Bellman-Ford Algorithm (Section \ref{section:BellmanFord}):
\begin{rbox}
V,E,r = gets.split(' ').map(&:to_i) # Input
Edge = []
E.times{
  s,t,d = gets.split(' ').map(&:to_i)
  Edge << [s, t, d]
}
Inf = 10000*100000+100 # Maximum if all vertices are traversed
C = Array.new(V,Inf) # Upper bound of the distance from the starting point to each vertex
C[r] = 0 # Starting point
V.times{ # V times
  count = 0
  Edge.each{|s,t,d| # For all edges (from s to t, cost d)
    if C[s] < Inf && C[t] > C[s]+d
      C[t] = C[s]+d # Update C[t]
      count += 1
    end
  }
  break if count == 0 # If no updates, it's okay to finish
}

V.times{|i|
  puts (C[i] == Inf) ? "INF" : C[i]
}
\end{rbox}

\section{Numerical Integration}
This section mainly introduces sample code related to Chapter \ref{chapter:integral}.

\subsection{Find the Outlier}
\begin{rbox}[emph={interpolate}]
# Assume values are in array \$V
def interpolate(n, e)
  sum = 0.0
  $V.each_index{|k|
    next if k == n || k == e # if k is n or E
    p = $V[k]
    $V.each_index{|i|
      p *= 1.0*(n-i)/(k-i) if i != k && i != n && i != e # if i is not k, n, or E
    }
    sum += p
  }
  sum
end
\end{rbox}

\begin{rbox}[emph={},emph={[2]outlier,interpolate}]
require 'scanf'
# Function definition
while true
  d = (scanf '\%d')[0]
  break if d == 0
  $V = scanf('\%f'*(d+3))
  (0..d+2).each {|i|
    if interpolate(i, -1) == $V[i] # if ignoring i makes everything consistent
      puts i
      break
    end
  }
end
\end{rbox}

\subsection{Intersection of Two Prisms}

\begin{rbox}[emph={width},emph={[2]w}]
def width(polygon, x) # polygon contains the coordinates of the x-y or x-z plane in order
  w = []
  polygon.each_index{|i|
    p, q = polygon[i], polygon[(i+1) % polygon.length]
    # Consider the edge pq
    if p[0] == x
      w << p[1]
    elsif (p[0] < x && x < q[0]) || (p[0] > x && x > q[0])
      x0, y0 = p[0], p[1]
      x1, y1 = q[0], q[1]
      x0, y0, x1, y1 = x1, y1, x0, y0 if p[0] > x
      w << y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0)
    end
  }
  raise if w.length == 0
  w.max - w.min
end
\end{rbox}

\begin{rbox}[emph={volume},emph={[2]width,total}]
def volume
  $X.sort!
  $X.uniq!
  sum = 0.0
  xmin = [($P1.min)[0], ($P2.min)[0]].max
  xmax = [($P1.max)[0], ($P2.max)[0]].min
  (0..$X.length-2).each{ |i|
    a, b = $X[i], $X[i+1]
    next unless xmin <= a && a <= xmax && xmin <= b && b <= xmax
    m = (a+b)/2.0
    va = width($P1, a)*width($P2, a)
    vb = width($P1, b)*width($P2, b)
    vm = width($P1, m)*width($P2, m)
    area = (b-a)*(va+4*vm+vb)/6.0 # Integral of the quadratic equation passing through (a,va), (m,vm), (b,vb) in the interval [a,b]
    sum += area
  }
  sum
end
\end{rbox}